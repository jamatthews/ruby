#include "internal.h"
#include "internal/compile.h"

#include "dynasm_jit.h"
#include "dynasm/dasm_proto.h"
#include "dynasm/dasm_x86.h"

#include <sys/mman.h>
#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
#define MAP_ANONYMOUS MAP_ANON
#endif

#include "vm_core.h"
#include "vm_callinfo.h"
#include "vm_exec.h"
#include "vm_insnhelper.h"


#include "builtin.h"
#include "insns.inc"
#include "insns_info.inc"

#ifndef DJ_CHECK_MODE
#define DJ_CHECK_MODE 0
#endif
#define DJ_ASSERT(expr) RUBY_ASSERT_MESG_WHEN(DJ_CHECK_MODE > 0, expr, #expr)

#define CFP_PC_OFFSET offsetof(rb_control_frame_t, pc)
#define CFP_SP_OFFSET offsetof(rb_control_frame_t, sp)

#define EC_IM_OFFSET offsetof(rb_execution_context_t, interrupt_mask)
#define EC_IF_OFFSET offsetof(rb_execution_context_t, interrupt_flag)

typedef rb_control_frame_t* (*insn_function)(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp);
typedef rb_control_frame_t* (*dynamic_assembeled_function)(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp);

static dynamic_assembeled_function jit_compile(rb_execution_context_t *ec);
static insn_function* insn_functions_table;
static void emit_call_to_insn_function(int insn, dasm_State** Dst);
static void emit_interrupt_check(int insn, dasm_State** Dst);

static void* link_and_encode(dasm_State** d)
{
  size_t sz;
  void* buf;
  dasm_link(d, &sz);
  buf = mmap(0, sz, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  dasm_encode(d, buf);
  mprotect(buf, sz, PROT_READ | PROT_EXEC);
  return buf;
}

VALUE dynasm_jit_exec(rb_execution_context_t *ec)
{
  rb_thread_t *th = rb_ec_thread_ptr(ec);
  rb_control_frame_t *reg_cfp = ec->cfp;
  struct rb_iseq_constant_body *body = reg_cfp->iseq->body;

  if(body->dynasm_jit_func == NULL) {
    body->dynasm_jit_func = jit_compile(ec);
  }

  if(body->dynasm_jit_func == NULL) {
    return Qundef;
  }
  reg_cfp = body->dynasm_jit_func(ec, reg_cfp);
  if (th->retval != Qundef) {
    VALUE ret = th->retval;
    th->retval = Qundef;

    return ret;
  } else {
    VALUE err = ec->errinfo;
    ec->errinfo = Qnil;
    return err;
  }
}

void
Init_DynasmVm(void)
{
  insn_functions_table = (insn_function*) rb_vm_get_insn_functions_table();
}

void debug(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp, int insn_context_thread)
{
  int insn_vpc = rb_vm_insn_addr2insn((void *) *reg_cfp->pc);
#if DJ_CHECK_MODE >= 1
  if(insn_vpc != insn_context_thread)
    fprintf(stderr, "insn_context_thread: %s insn_vpc: %s, ec: %p, ec_cfp: %p, reg_cfp: %p, sp: %p, pc: %p\n", insn_name(insn_context_thread), insn_name(insn_vpc), ec, ec->cfp, reg_cfp, reg_cfp->sp, reg_cfp->pc);
#endif
  DJ_ASSERT(insn_vpc == insn_context_thread);

#if DJ_CHECK_MODE >= 2
  fprintf(stderr, "insn_context_thread: %s insn_vpc: %s, ec: %p, ec_cfp: %p, reg_cfp: %p, sp: %p, pc: %p\n", insn_name(insn_context_thread), insn_name(insn_vpc), ec, ec->cfp, reg_cfp, reg_cfp->sp, reg_cfp->pc);
#endif
}

void print_compiled_iseq(rb_execution_context_t *ec){
  const struct rb_iseq_constant_body *body = ec->cfp->iseq->body;
  unsigned int pos = 0;
  int insn;
  fprintf(stderr, "compiled: \n");

  while (pos < body->iseq_size) {
    insn = rb_vm_insn_addr2insn((void *)body->iseq_encoded[pos]);
    fprintf(stderr, "%s %p\n", insn_name(insn), body->iseq_encoded + pos);
    switch(insn) {
      case BIN(jump):
        fprintf(stderr, "  target %p\n", body->iseq_encoded + pos + insn_len(insn) + body->iseq_encoded[pos+1]);
        break;
      case BIN(branchunless):
        fprintf(stderr, "  fallthrough %p\n",body->iseq_encoded + pos + insn_len(insn));
        fprintf(stderr, "  target %p\n", body->iseq_encoded + pos + insn_len(insn) + body->iseq_encoded[pos+1]);
        break;

    }
    pos += insn_len(insn);
  }
}

static dynamic_assembeled_function
jit_compile(rb_execution_context_t *ec)
{
  const struct rb_iseq_constant_body *body = ec->cfp->iseq->body;
  dasm_State* d;
  |.arch x64
  |.section code
  dasm_init(&d, DASM_MAXSECTION);
  |.globals lbl_
  void* labels[lbl__MAX];
  dasm_State** Dst = &d;
  dasm_setupglobal(&d, labels, lbl__MAX);
  |.actionlist actions
  dasm_setup(&d, actions);
  dasm_growpc(&d, body->iseq_size);
  |.code
  |->exception_handler:
    | ret
  |->main:
  unsigned int pos = 0;
  int insn;

  if(body->param.flags.has_opt){
    return NULL; //handle this with a jump table for starting PC later
  }

  while (pos < body->iseq_size) {
    |=>pos:
    insn = rb_vm_insn_addr2insn((void *)body->iseq_encoded[pos]);
    switch(insn){
      case BIN(leave):
        emit_call_to_insn_function(insn, Dst);
        | ret
        break;
      case BIN(jump):
        | mov rcx, [rdi+EC_IM_OFFSET]
        | not rcx
        | test rcx, [rdi+EC_IF_OFFSET]
        | jz >1
        emit_call_to_insn_function(insn, Dst);
        | jmp >2
        | 1:
        | add qword [rsi], 8 * (insn_len(insn) + body->iseq_encoded[pos+1]) //move vPC
        | 2:
        | jmp => (pos + body->iseq_encoded[pos+1] + insn_len(insn)) // current_pc + offset argument + fake dispatch
        break;
      case BIN(branchif):
        | mov rcx, [rdi+EC_IM_OFFSET]
        | not rcx
        | test rcx, [rdi+EC_IF_OFFSET]
        | jz >1

        // interrupts raised, call original instruction
        emit_call_to_insn_function(insn, Dst);
        | mov64 rcx, (uint64_t)(body->iseq_encoded + pos + insn_len(insn))
        | cmp rcx, [rax]
        | jne => pos + body->iseq_encoded[pos+1] + insn_len(insn) // current_pc + offset argument
        | jmp => pos + insn_len(insn)

        // test top of stack
        | 1:
        | sub qword [rsi+CFP_SP_OFFSET], sizeof(VALUE)
        | mov rcx, qword [rsi+CFP_SP_OFFSET]
        | mov rcx, qword [rcx]
        | test rcx, ~Qnil
        | jz >2

        //
        | add qword [rsi], sizeof(VALUE) * (insn_len(insn) + body->iseq_encoded[pos+1]) //move vPC
        | jmp => (pos + body->iseq_encoded[pos+1] + insn_len(insn)) // current_pc + offset argument + fake dispatch

        // fall-through
        | 2:
        | add qword [rsi], sizeof(VALUE) * (insn_len(insn)) //move vPC
        break;
      case BIN(pop):
        | add qword [rsi+CFP_PC_OFFSET], sizeof(VALUE) * (insn_len(insn)) //move vPC
        | sub qword [rsi+CFP_SP_OFFSET], sizeof(VALUE) //move vSP
        break;
      case BIN(branchunless):
      case BIN(branchnil):
      case BIN(opt_getinlinecache):
        emit_call_to_insn_function(insn, Dst);

        | mov64 rcx, (uint64_t)(body->iseq_encoded + pos + insn_len(insn))
        | cmp rcx, [rax]
        | jne => pos + body->iseq_encoded[pos+1] + insn_len(insn) // current_pc + offset argument
        break;
      case BIN(defineclass): // defineclass pushes a frame and just startes executing a differen
      case BIN(opt_case_dispatch): //need to build a lookup table for jump

        //fprintf(stderr, "compilation terminated by unsupported instruction: %s\n", insn_name(insn));
        return NULL;
      default:
        emit_call_to_insn_function(insn, Dst);
    }
    pos += insn_len(insn);
  }
#if DJ_CHECK_MODE >= 2
  print_compiled_iseq(ec);
#endif
  link_and_encode(&d);
  dasm_free(&d);
  return (dynamic_assembeled_function) labels[lbl_main];
}

static void precall(dasm_State** Dst){
  | push rdi
  | push rsi
  | push rsi
}

static void postcall(dasm_State** Dst){
  | pop rsi
  | pop rsi
  | pop rdi
}

static void pre_insn_debug(int insn, dasm_State** Dst){
  precall(Dst);
  | mov64 rdx, (uint64_t)(insn)
  | mov64 rax, (uint64_t)(debug)
  | call rax
  postcall(Dst);
}

static void check_for_exception(dasm_State** Dst){
  | cmp rax, 0
  | je ->exception_handler //If an instruction raises an exception (like throw) it returns 0
  | mov rsi, rax // Normal case. An instruction returns the (potentially updated) control frame pointer.
}

static void emit_call_to_insn_function(int insn, dasm_State** Dst)
{
  if(DJ_CHECK_MODE > 0)
    pre_insn_debug(insn, Dst);
  // save first (ec) and second (cfp) arguments
  precall(Dst);
  // call the VM implementation for this isntruction
  | mov64 rax, (uint64_t)(insn_functions_table[insn])
  | call rax
  postcall(Dst);
  // save first (ec) and second (cfp) arguments
  check_for_exception(Dst);
}
