#include "internal.h"
#include "internal/compile.h"

#include "dynasm_jit.h"
#include "dynasm/dasm_proto.h"
#include "dynasm/dasm_x86.h"

#include <sys/mman.h>
#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
#define MAP_ANONYMOUS MAP_ANON
#endif

#include "vm_core.h"
#include "vm_callinfo.h"
#include "vm_exec.h"
#include "vm_insnhelper.h"


#include "builtin.h"
#include "insns.inc"
#include "insns_info.inc"

typedef rb_control_frame_t* (*insn_function)(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp);
typedef rb_control_frame_t* (*dynamic_assembeled_function)(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp);

static dynamic_assembeled_function jit_compile(rb_execution_context_t *ec);
static insn_function* insn_functions_table;
static void jit_insn(int insn, dasm_State** Dst);

static void* link_and_encode(dasm_State** d)
{
  size_t sz;
  void* buf;
  dasm_link(d, &sz);
  buf = mmap(0, sz, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
  dasm_encode(d, buf);
  mprotect(buf, sz, PROT_READ | PROT_EXEC);
  return buf;
}

VALUE dynasm_jit_exec(rb_execution_context_t *ec)
{
  rb_thread_t *th = rb_ec_thread_ptr(ec);
  rb_control_frame_t *reg_cfp = ec->cfp;
  dynamic_assembeled_function jit_function = jit_compile(ec);
  if(jit_function) {
    reg_cfp = jit_function(ec, reg_cfp);
    if (th->retval != Qundef) {
      VALUE ret = th->retval;
      th->retval = Qundef;

      return ret;
    } else {
      VALUE err = ec->errinfo;
      ec->errinfo = Qnil;
      return err;
    }
  } else {
    return Qundef;
  }
}

void
Init_DynasmVm(void)
{
  insn_functions_table = (insn_function*) rb_vm_get_insn_functions_table();
}

// void debug(rb_execution_context_t *ec, rb_control_frame_t *reg_cfp, int insn_calling)
// {
//   int insn = rb_vm_insn_addr2insn(*reg_cfp->pc);
//   if(insn != insn_calling) {
//     fprintf(stderr, "insn_calling: %s insn vpc: %s, ec: %p, ec_cfp: %p, reg_cfp: %p, sp: %p, pc: %p\n", insn_name(insn_calling), insn_name(insn), ec, ec->cfp, reg_cfp, reg_cfp->sp, reg_cfp->pc);
//   }
// }

// void dump_rdi(VALUE rdi)
// {
//   fprintf(stderr, "rdi: %p\n", rdi);
// }

static dynamic_assembeled_function
jit_compile(rb_execution_context_t *ec)
{
  const struct rb_iseq_constant_body *body = ec->cfp->iseq->body;
  dasm_State* d;
  |.arch x64
  |.section code
  dasm_init(&d, DASM_MAXSECTION);
  |.globals lbl_
  void* labels[lbl__MAX];
  dasm_State** Dst = &d;
  dasm_setupglobal(&d, labels, lbl__MAX);
  |.actionlist actions
  dasm_setup(&d, actions);
  dasm_growpc(&d, body->iseq_size);
  |.code
  |->exception_handler:
    | ret
  |->start:
  unsigned int pos = 0;
  int insn;

  while (pos < body->iseq_size) {
    |=>pos:
    insn = rb_vm_insn_addr2insn((void *)body->iseq_encoded[pos]);
    switch(insn){
      case BIN(leave):
        jit_insn(insn, Dst);
        | ret
        break;
      case BIN(jump):
        jit_insn(insn, Dst);
        | jmp => pos + body->iseq_encoded[pos+1] + insn_len(insn) // current_pc + offset argument + fake dispatch
        break;
      case BIN(branchif):
      case BIN(branchunless):
      case BIN(branchnil):
        jit_insn(insn, Dst);

        | mov64 rcx, (uint64_t)(body->iseq_encoded + pos + insn_len(insn))
        | cmp rcx, [rax]
        | jne => pos + body->iseq_encoded[pos+1] + insn_len(insn) // current_pc + offset argument
        break;
      case BIN(getinstancevariable): //no idea about these two
      case BIN(setinstancevariable):
      case BIN(defineclass): // need to investigate why this causes an error and the debug output can't even print
      case BIN(send): //stack consistency error
      case BIN(opt_send_without_block): //stack consistency error
      case BIN(invokesuper): //stack consistency error
      case BIN(invokeblock): //stack consistency error
      case BIN(throw): //segfault
      case BIN(opt_case_dispatch): //need to build a lookup table for jump
      case BIN(opt_getinlinecache): // handling like a branch didn't work
      case BIN(opt_eq): // no idea
      case BIN(opt_ltlt): // no idea
      case BIN(opt_regexpmatch2):
      case BIN(invokebuiltin):
      case BIN(opt_invokebuiltin_delegate):
      case BIN(opt_invokebuiltin_delegate_leave):
      case BIN(opt_mod):
      case BIN(opt_aref):
      case BIN(opt_aset):
        //fprintf(stderr, "compilation terminated by unsupported instruction: %s\n", insn_name(insn));
        return NULL;
      case BIN(getlocal_WC_0):
      case BIN(getlocal_WC_1):
      case BIN(setlocal_WC_0):
      case BIN(setlocal_WC_1):
      case BIN(putobject_INT2FIX_0_):
      case BIN(putobject_INT2FIX_1_):
        jit_insn(insn, Dst);
        break;
      default:
        jit_insn(insn, Dst);
    }
    pos += insn_len(insn);
  }
  // pos = 0;
  // fprintf(stderr, "compiled: \n");
  // while (pos < body->iseq_size) {
  //   insn = rb_vm_insn_addr2insn((void *)body->iseq_encoded[pos]);
  //   switch(insn) {
  //     case BIN(branchunless):
  //       fprintf(stderr, "%s next insn %p\n", insn_name(insn), body->iseq_encoded + pos + insn_len(insn));
  //       break;
  //     default:
  //       fprintf(stderr, "%s\n", insn_name(insn));
  //   }
  //   pos += insn_len(insn);
  // }
  link_and_encode(&d);
  dasm_free(&d);
  return (dynamic_assembeled_function) labels[lbl_start];
}

// the two arg passing registeres get call clobbered
static void precall(dasm_State** Dst){
  | push rdi
  | push rsi
  | push rsp
  //IDK why but this seems to be on 16 byte alignment with only 3 registers pushed
}

// the two arg passing registeres get call clobbered
static void postcall(dasm_State** Dst){
  //IDK why but this seems to be on 16 byte alignment with only 3 registers pushed
  | pop rsp
  | pop rsi
  | pop rdi
}

static void jit_insn(int insn, dasm_State** Dst)
{
  // precall(Dst);
  // | mov64 rdx, (uint64_t)(insn)
  // | mov64 rax, (uint64_t)(debug)
  // | call rax
  // postcall(Dst);
  precall(Dst);
  | mov64 rax, (uint64_t)(insn_functions_table[insn])
  | call rax
  postcall(Dst);
  | cmp rax, 0
  | je ->exception_handler //If an instruction raises an exception (like throw) it returns 0
  | mov rsi, rax // Normal case. An instruction returns the (potentially updated) control frame pointer.
}
